<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Infiltr√© ‚Äî Vue TV</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.2/dist/confetti.browser.min.js"></script>
  <link rel="stylesheet" href="css/animations.css">
  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          colors: {
            neon: { green: '#00ff88', pink: '#ff0080', cyan: '#00d4ff' }
          }
        }
      }
    }
  </script>
  <style>
    body { background: #0a0a0f; }
    .font-mono { font-family: ui-monospace, monospace; }
  </style>
</head>
<body class="min-h-screen bg-[#0a0a0f] text-gray-100 overflow-hidden">
  <div id="app" class="min-h-screen flex flex-col p-6 md:p-10">
    <header class="flex flex-wrap items-center justify-between gap-4 mb-6">
      <h1 class="text-2xl md:text-3xl font-bold text-neon-green">Infiltr√©</h1>
      <p class="text-lg text-gray-300 max-w-2xl">{{ statusMessage }}</p>
      <div class="font-mono text-2xl md:text-4xl text-neon-cyan tabular-nums">
        {{ formattedTimer }}
      </div>
    </header>

    <!-- Banni√®re Mission en cours -->
    <section
      v-if="isMissionActive"
      class="mb-8 p-6 rounded-xl bg-neon-green/10 border-2 border-neon-green text-center"
    >
      <p class="text-neon-green font-bold text-xl md:text-2xl mb-2">Mission en cours</p>
      <p class="text-gray-300 mb-2">{{ gameState.stateMessage }}</p>
      <p class="font-mono text-3xl md:text-4xl text-neon-cyan">{{ formattedTimer }}</p>
    </section>

    <!-- Joueurs connect√©s -->
    <section class="mb-8">
      <h2 class="text-xl text-neon-cyan mb-4">Joueurs connect√©s ({{ players.length }})</h2>
      <div class="flex flex-wrap gap-2">
        <span
          v-for="p in players"
          :key="p.id"
          class="px-4 py-2 rounded-lg bg-gray-800 border border-gray-600 text-white"
        >
          {{ p.name }}
        </span>
      </div>
      <p v-if="players.length === 0" class="text-gray-500">Aucun joueur pour l'instant.</p>
    </section>

    <section class="mb-8">
      <h2 class="text-xl text-neon-pink mb-4">Classement</h2>
      <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-3">
        <div
          v-for="(entry, index) in leaderboardList"
          :key="entry.name + index"
          class="flex items-center justify-between p-4 rounded-lg bg-gray-800/60 border border-gray-700"
        >
          <span class="font-medium text-white">{{ entry.name || 'Joueur' }}</span>
          <div class="flex gap-4 text-sm">
            <span class="text-neon-green">‚úì {{ entry.score || 0 }}</span>
            <span class="text-neon-pink">üç∫ {{ entry.gages || 0 }}</span>
          </div>
        </div>
      </div>
      <p v-if="leaderboardList.length === 0" class="text-gray-500">Aucun score pour l'instant.</p>
    </section>

    <!-- Pop-up R√âV√âLATION : mission termin√©e, que l'agent se d√©nonce -->
    <div
      v-show="showRevealPopup"
      class="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/80"
      @click.self="closeRevealPopup"
    >
      <div
        class="reveal-popup max-w-2xl w-full p-8 md:p-12 rounded-2xl bg-gray-900 border-2 border-neon-green shadow-2xl"
        :class="{ 'reveal-trigger': revealTrigger }"
      >
        <p class="text-neon-pink text-sm uppercase tracking-wider mb-2">Temps √©coul√©</p>
        <p class="text-2xl md:text-3xl font-bold text-neon-green mb-6">La mission est termin√©e !</p>
        <p class="text-xl text-white mb-8">Que l'agent se d√©nonce !</p>
        <p class="text-gray-400 text-sm mb-2">L'agent √©tait</p>
        <p class="reveal-agent-name text-xl font-bold text-neon-cyan mb-4">
          {{ gameState.agentName || '‚Äî' }}
        </p>
        <p class="text-gray-400 text-sm mb-2">Sa mission √©tait</p>
        <p class="reveal-mission text-lg text-gray-300 leading-relaxed mb-6">
          {{ gameState.mission || '‚Äî' }}
        </p>
        <button
          @click="closeRevealPopup"
          class="px-6 py-2 rounded-lg bg-gray-700 text-gray-300 hover:bg-gray-600 transition"
        >
          Fermer
        </button>
      </div>
    </div>
  </div>

  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <script src="js/firebase-config.js"></script>
  <script src="js/app.js"></script>
  <script>
    const { createApp } = Vue;

    createApp({
      data() {
        return {
          gameState: {},
          players: [],
          timerInterval: null,
          revealTimeoutInterval: null,
          now: Date.now(),
          showRevealPopup: false,
          revealTrigger: false
        };
      },
      computed: {
        statusMessage() {
          const msg = this.gameState.stateMessage;
          if (msg) return msg;
          return this.gameState.state ? 'Chargement...' : 'En attente de la partie...';
        },
        isMissionActive() {
          const s = this.gameState.state;
          return s === InfiltreGame.STATES.INFILTRATION || s === InfiltreGame.STATES.PAUSED;
        },
        leaderboardList() {
          const lb = this.gameState.leaderboard || {};
          const byKey = {};
          for (const p of this.players) {
            const key = (p.name && String(p.name).trim()) || p.id;
            if (!key) continue;
            byKey[key] = { name: p.name || 'Joueur', score: 0, gages: 0 };
          }
          for (const [id, v] of Object.entries(lb)) {
            const key = (v && v.name && String(v.name).trim()) ? String(v.name).trim() : id;
            if (!byKey[key]) byKey[key] = { name: (v && v.name) ? String(v.name).trim() : id, score: 0, gages: 0 };
            byKey[key].score += (v && v.score) || 0;
            byKey[key].gages += (v && v.gages) || 0;
          }
          return Object.values(byKey).sort((a, b) => (b.score || 0) - (a.score || 0));
        },
        formattedTimer() {
          const state = this.gameState.state;
          const revealAt = this.gameState.revealAt;
          const remainingSeconds = this.gameState.remainingSeconds;
          if (state === InfiltreGame.STATES.PAUSED && remainingSeconds != null) {
            const m = Math.floor(remainingSeconds / 60);
            const s = Math.floor(remainingSeconds % 60);
            return m + ':' + (s < 10 ? '0' : '') + s;
          }
          if (state !== InfiltreGame.STATES.INFILTRATION || !revealAt) {
            return '--:--';
          }
          const remaining = Math.max(0, Math.floor((revealAt - this.now) / 1000));
          const m = Math.floor(remaining / 60);
          const s = remaining % 60;
          return m + ':' + (s < 10 ? '0' : '') + s;
        }
      },
      watch: {
        'gameState.state'(newState) {
          if (newState === InfiltreGame.STATES.REVEAL) {
            this.showRevealPopup = true;
            this.revealTrigger = true;
            setTimeout(() => {
              if (typeof confetti === 'function') {
                confetti({ particleCount: 80, spread: 60 });
              }
            }, 400);
          }
        }
      },
      mounted() {
        InfiltreGame.onGameState((state) => {
          this.gameState = typeof state === 'object' && state !== null ? { ...state } : {};
        });
        InfiltreGame.onPlayers((list) => {
          this.players = list || [];
        });
        this.timerInterval = setInterval(() => {
          this.now = Date.now();
          if (this.gameState.state === InfiltreGame.STATES.INFILTRATION && this.gameState.revealAt && this.now >= this.gameState.revealAt) {
            InfiltreGame.triggerReveal();
          }
        }, 1000);
        this.revealTimeoutInterval = setInterval(() => {
          InfiltreGame.checkRevealTimeout();
        }, 30000);
      },
      beforeUnmount() {
        if (this.timerInterval) clearInterval(this.timerInterval);
        if (this.revealTimeoutInterval) clearInterval(this.revealTimeoutInterval);
      },
      methods: {
        closeRevealPopup() {
          this.showRevealPopup = false;
          this.revealTrigger = false;
        }
      }
    }).mount('#app');
  </script>
</body>
</html>
